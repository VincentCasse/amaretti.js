{"version":3,"sources":["app/amaretti.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"public/amaretti.js","sourcesContent":["\"use strict\";\n\nvar encode = function(str) {\n\treturn new TextEncoder('utf-8').encode(str);\n};\nvar decode = function(buf) {\n\treturn new TextDecoder('utf-8').decode(new Uint8Array(buf));\n};\n/*var ab2str = function(buf) {\n\treturn String.fromCharCode.apply(null, new Uint16Array(buf));\n};*/\nfunction b64ToUint6 (nChr) {\n\n  return nChr > 64 && nChr < 91 ?\n      nChr - 65\n    : nChr > 96 && nChr < 123 ?\n      nChr - 71\n    : nChr > 47 && nChr < 58 ?\n      nChr + 4\n    : nChr === 43 ?\n      62\n    : nChr === 47 ?\n      63\n    :\n      0;\n\n}\n\nfunction arrayBufferToBase64 (arrayBuffer) {\n\treturn btoa(String.fromCharCode.apply(null, new Uint8Array(arrayBuffer)));\n}\n/**\n* TODO add better way to use atob whe possible\n*/\n//https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#Appendix.3A_Decode_a_Base64_string_to_Uint8Array_or_ArrayBuffer\nfunction base64ToArrayByte(sBase64, nBlocksSize) { \n\n  var\n    sB64Enc = sBase64.replace(/[^A-Za-z0-9\\+\\/]/g, \"\"), nInLen = sB64Enc.length,\n    nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2, taBytes = new Uint8Array(nOutLen);\n\n  for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {\n    nMod4 = nInIdx & 3;\n    nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 6 * (3 - nMod4);\n    if (nMod4 === 3 || nInLen - nInIdx === 1) {\n      for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {\n        taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;\n      }\n      nUint24 = 0;\n\n    }\n  }\n\n  return taBytes;\n\n}\nvar arrayByteToBase64 = function(arrayByte) {\n\t//http://stackoverflow.com/a/12713326\n\tvar CHUNK_SZ = 0x8000;\n\tvar c = [];\n\tfor (var i = 0; i < arrayByte.length; i += CHUNK_SZ) {\n\t\tc.push(String.fromCharCode.apply(\n\t\t\tnull,\n\t\t\tarrayByte.subarray(i, i + CHUNK_SZ)\n\t\t));\n\t}\n\treturn btoa(c.join(''));\n};\n\nvar Amaretti = {\n\n\tauthTagLength : 128,\n\tparanoia: 10,\n\titerations: 5000,\n\tenableNative: true,\n\n\tinit: function (opts) {\n\t\tthis.authTagUsedSpace = this.authTagLength / 4;\n\t\tsjcl.random.startCollectors();\n\n\t\tif (opts) {\n\t\t\tthis.iterations = opts.iterations ? opts.iterations : 5000;\n\t\t\tthis.enableNative = opts.enableNative !== undefined ? opts.enableNative : true; \n\t\t}\n\t\treturn this;\n\t},\n\n\tgetCrypto: function() {\n\t\treturn window.crypto || window.msCrypto;\n\t},\n\n\tgetSalt: function() {\n\t\tvar origSalt;\n\t\tvar salt;\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tif (Amaretti.enableNative &&\n\t\t\t\tAmaretti.getCrypto() &&\n\t\t\t\tAmaretti.getCrypto().getRandomValues) {\n\t\t\t\ttry {\n\t\t\t\t\torigSalt = Amaretti.getCrypto().getRandomValues(new Uint8Array(64));\n\t\t\t\t\tsalt = arrayByteToBase64(origSalt);\n\t\t\t\t\tresolve(salt);\n\t\t\t\t} catch (exception) {\n\t\t\t\t\treject(exception.message);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (sjcl.random.isReady(Amaretti.paranoia) === 0) {\n\t\t\t\treject('sjcl random is not ready');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\torigSalt = sjcl.random.randomWords(8, Amaretti.paranoia);\n\t\t\t\tsalt = sjcl.codec.base64.fromBits(origSalt);\n\t\t\t\tresolve(salt);\n\t\t\t} catch (exception) {\n\t\t\t\treject(exception.message);\n\t\t\t}\n\t\t});\n\t},\n\n\tgenerateKey: function(passphrase, salt, algo) {\n\t\tif (!algo) {\n\t\t\treturn new Promise(function(resolve, reject) {\n\t\t\t\treject('Please add an algo');\n\t\t\t});\n\t\t}\n\n\t\tif (Amaretti.enableNative &&\n\t\t\tAmaretti.getCrypto() &&\n\t\t\tAmaretti.getCrypto().subtle &&\n\t\t\tAmaretti.getCrypto().subtle.importKey && \n\t\t\tAmaretti.getCrypto().subtle.deriveKey && \n\t\t\tAmaretti.getCrypto().subtle.exportKey) {\n\n\t\t\treturn Amaretti.getCrypto().subtle.importKey(\n\t\t\t\t'raw',\n\t\t\t\tencode(passphrase),\n\t\t\t\t{ name: 'PBKDF2' },\n\t\t\t\tfalse,\n\t\t\t\t['deriveKey']\n\t\t\t).then(function(baseKey) {\n\n\t\t\t\tvar cryptoAlgo;\n\t\t\t\tif (algo === 'SHA-1') {\n\t\t\t\t\tcryptoAlgo = 'SHA-1';\n\t\t\t\t} else if (algo === 'SHA-256') {\n\t\t\t\t\tthrow 'SHA-256 is not yet available on firefox';\n\t\t\t\t} else {\n\t\t\t\t\tthrow 'Your algo is not available';\n\t\t\t\t}\n\n\t\t\t\treturn Amaretti.getCrypto().subtle.deriveKey(\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'PBKDF2',\n\t\t\t\t\t\thash: cryptoAlgo,\n\t\t\t\t\t\tsalt: base64ToArrayByte(salt),\n\t\t\t\t\t\titerations: Amaretti.iterations\n\t\t\t\t\t},\n\t\t\t\t\tbaseKey,\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'AES-GCM',\n\t\t\t\t\t\tlength: 256\n\t\t\t\t\t},\n\t\t\t\t\ttrue,\n\t\t\t\t\t['encrypt', 'decrypt']\n\t\t\t\t).then(function (key) {\n\t\t\t\t\treturn Amaretti.getCrypto().subtle.exportKey('raw', key)\n\t\t\t\t\t\t.then(function (rawKey) {\n\t\t\t\t\t\t\treturn new Promise(function(resolve, reject) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t \t\tresolve(arrayByteToBase64(new Uint8Array(rawKey)));\n\t\t\t\t\t\t\t \t} catch (exception) {\n\t\t\t\t\t\t\t \t\treject(exception.message);\n\t\t\t\t\t\t\t \t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\treturn new Promise(function(resolve, reject) {\n\t\t\t\ttry {\n\t\t\t\t\tvar sjclAlgo;\n\n\t\t\t\t\tif (algo === 'SHA-1') {\n\t\t\t\t\t\tsjclAlgo = function (key) {\n\t\t\t\t\t\t\t// todo sha-1\n\t\t\t\t\t    \tvar hasher = new sjcl.misc.hmac( key, sjcl.hash.sha256 );\n\t\t\t\t\t\t    this.encrypt = function () {\n\t\t\t\t\t\t        return hasher.encrypt.apply( hasher, arguments );\n\t\t\t\t\t\t    };\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (algo === 'SHA-256') {\n\t\t\t\t\t\tsjclAlgo = function (key) {\n\t\t\t\t\t    \tvar hasher = new sjcl.misc.hmac( key, sjcl.hash.sha256 );\n\t\t\t\t\t\t    this.encrypt = function () {\n\t\t\t\t\t\t        return hasher.encrypt.apply( hasher, arguments );\n\t\t\t\t\t\t    };\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow 'Your algo is not available';\n\t\t\t\t\t}\n\n\t\t\t\t\tvar key = sjcl.misc.pbkdf2(\n\t\t\t\t\t\tpassphrase,\n\t\t\t\t\t\tsjcl.codec.base64.toBits(salt),\n\t\t\t\t\t\tAmaretti.iterations,\n\t\t\t\t\t\t256,\n\t\t\t\t\t\tsjclAlgo\n\t\t\t\t\t);\n\t\t\t\t\t// TODO fix SHA1\n\t\t\t\t\t// https://github.com/bitwiseshiftleft/sjcl/issues/75\n\t\t\t\t\tresolve(sjcl.codec.base64.fromBits(key));\n\t\t\t\t} catch (exception) {\n\t\t\t\t\treject(exception.message);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\n\tencrypt: function(key, message, nonce) {\n\t\tif (Amaretti.enableNative &&\n\t\t\tAmaretti.getCrypto() &&\n\t\t\tAmaretti.getCrypto().subtle &&\n\t\t\tAmaretti.getCrypto().subtle.importKey &&\n\t\t\tAmaretti.getCrypto().subtle.encrypt) {\n\n\t\t\treturn Amaretti.getCrypto().subtle.importKey(\n\t\t\t\t'raw',\n\t\t\t\tbase64ToArrayByte(key),\n\t\t\t\t{\n\t\t\t\t\tname: 'AES-GCM',\n\t\t\t\t\tlength: 256\n\t\t\t\t},\n\t\t\t\ttrue,\n\t\t\t\t['encrypt', 'decrypt']\n\t\t\t).then(function (rawKey) {\n\t\t\t\t\n\t\t\t\treturn Amaretti.getCrypto().subtle.encrypt(\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'AES-GCM',\n\t\t\t\t\t\tiv: base64ToArrayByte(nonce),\n\t\t\t\t\t\ttagLength: Amaretti.authTagLength\n\t\t\t\t\t},\n\t\t\t\t\trawKey,\n\t\t\t\t\tencode(message)\n\t\t\t\t).then(function (crypted) {\n\t\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\t\ttry {\t\n\t\t\t\t\t\t\tresolve(arrayBufferToBase64(crypted));\n\t\t\t\t\t\t} catch (exception) {\n\t\t\t\t\t\t\treject(exception.message);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\treturn new Promise(function(resolve, reject) {\n\t\t\t\ttry {\n\t\t\t\t\tvar rawKey = sjcl.codec.base64.toBits(key);\n\t\t\t\t\tvar rawNonce = sjcl.codec.base64.toBits(nonce);\n\t\t\t\t\tvar keyAES = new sjcl.cipher.aes(rawKey);\n\t\t\t\t\tvar crypt = sjcl.mode.gcm.encrypt(\n\t\t\t\t\t\tkeyAES,\n\t\t\t\t\t\tsjcl.codec.utf8String.toBits(message),\n\t\t\t\t\t\trawNonce,\n\t\t\t\t\t\tsjcl.codec.utf8String.toBits(Amaretti.authData),\n\t\t\t\t\t\tAmaretti.authentificationTagLength);\n\n\t\t\t\t\tresolve(sjcl.codec.base64.fromBits(crypt));\n\t\t\t\t} catch (exception) {\n\t\t\t\t\treject(exception.message);\n\t\t\t\t}\n\t\t\t});\n\t\t}\t\n\t},\n\n\tdecrypt: function(key, crypted, nonce) {\n\n\t\tif (Amaretti.enableNative &&\n\t\t\tAmaretti.getCrypto() &&\n\t\t\tAmaretti.getCrypto().subtle &&\n\t\t\tAmaretti.getCrypto().subtle.importKey &&\n\t\t\tAmaretti.getCrypto().subtle.decrypt) {\n\n\t\t\treturn Amaretti.getCrypto().subtle.importKey(\n\t\t\t\t'raw',\n\t\t\t\tbase64ToArrayByte(key),\n\t\t\t\t{\n\t\t\t\t\tname: 'AES-GCM',\n\t\t\t\t\tlength: 256\n\t\t\t\t},\n\t\t\t\ttrue,\n\t\t\t\t['encrypt', 'decrypt']\n\t\t\t).then(function (rawKey) {\n\t\t\t\treturn Amaretti.getCrypto().subtle.decrypt(\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'AES-GCM',\n\t\t\t\t\t\tiv: base64ToArrayByte(nonce),\n\t\t\t\t\t\ttagLength: Amaretti.authTagLength\n\t\t\t\t\t},\n\t\t\t\t\trawKey,\n\t\t\t\t\tbase64ToArrayByte(crypted)\n\t\t\t\t).then(function(plaintext) {\n\t\t\t\t\treturn new Promise(function(resolve, reject) {\n\t\t\t\t\t\tresolve(decode(plaintext));\n\t\t\t\t\t});\n\t\t\t\t}, function (err) {\n\t\t\t\t\treturn new Promise(function(resolve, reject) {\n\t\t\t\t\t\treject('Integrity/Authenticity check failed! Invalid password?');\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\treturn new Promise(function(resolve, reject) {\n\t\t\t\ttry {\n\t\t\t\t\tvar rawKey = sjcl.codec.base64.toBits(key);\n\t\t\t\t\tvar rawNonce = sjcl.codec.base64.toBits(nonce);\n\t\t\t\t\tvar rawCrypted = sjcl.codec.base64.toBits(crypted);\n\t\t\t\t\tvar keyAES = new sjcl.cipher.aes(rawKey);\n\n\t\t\t\t\tvar crypt = sjcl.mode.gcm.decrypt(\n\t\t\t\t\t\tkeyAES,\n\t\t\t\t\t\trawCrypted,\n\t\t\t\t\t\trawNonce,\n\t\t\t\t\t\tsjcl.codec.utf8String.toBits(Amaretti.authData),\n\t\t\t\t\t\tAmaretti.authentificationTagLength);\n\t\t\t\t\tvar decrypt = sjcl.codec.utf8String.fromBits(crypt);\n\t\t\t\t\tresolve(decrypt);\n\t\t\t\t} catch (exception) {\n\t\t\t\t\treject(exception.message);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n};\n"]}